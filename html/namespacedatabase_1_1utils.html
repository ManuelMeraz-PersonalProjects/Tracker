<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tracker: database::utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tracker
   &#160;<span id="projectnumber">0.0.0</span>
   </div>
   <div id="projectbrief">Track macrnonutrients, micronutrients, and more</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacedatabase_1_1utils.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">database::utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility functions to insert, retrieve, and manipulate objects in database.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0dd569af49c9913a5090b71c86690fe5"><td class="memTemplParams" colspan="2">template&lt;class ForwardIt , class T , class Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a0dd569af49c9913a5090b71c86690fe5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedatabase_1_1utils.html#a0dd569af49c9913a5090b71c86690fe5">binary_find</a> (ForwardIt first, ForwardIt last, const T &amp;value, Compare comp) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a0dd569af49c9913a5090b71c86690fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns the object if it exists in the stl container.  <a href="#a0dd569af49c9913a5090b71c86690fe5">More...</a><br /></td></tr>
<tr class="separator:a0dd569af49c9913a5090b71c86690fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae24cb18f62390528243ff3218d8626"><td class="memTemplParams" colspan="2">template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:adae24cb18f62390528243ff3218d8626"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedatabase_1_1utils.html#adae24cb18f62390528243ff3218d8626">count_rows</a> () -&gt; size_t</td></tr>
<tr class="memdesc:adae24cb18f62390528243ff3218d8626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of <a class="el" href="classdatabase_1_1_storable.html">Storable</a> type in the database.  <a href="#adae24cb18f62390528243ff3218d8626">More...</a><br /></td></tr>
<tr class="separator:adae24cb18f62390528243ff3218d8626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303b59245b11befd59f3fd0e838ef80b"><td class="memTemplParams" colspan="2">template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a303b59245b11befd59f3fd0e838ef80b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedatabase_1_1utils.html#a303b59245b11befd59f3fd0e838ef80b">create_table</a> (std::vector&lt; <a class="el" href="structdatabase_1_1_column_properties.html">ColumnProperties</a> &gt; const &amp;schema)</td></tr>
<tr class="memdesc:a303b59245b11befd59f3fd0e838ef80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create table of <a class="el" href="classdatabase_1_1_storable.html">Storable</a> if not exists.  <a href="#a303b59245b11befd59f3fd0e838ef80b">More...</a><br /></td></tr>
<tr class="separator:a303b59245b11befd59f3fd0e838ef80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56bf4b6fc7b1481c84e42e6bb6db57b"><td class="memTemplParams" colspan="2">template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac56bf4b6fc7b1481c84e42e6bb6db57b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedatabase_1_1utils.html#ac56bf4b6fc7b1481c84e42e6bb6db57b">delete_storable</a> (<a class="el" href="classdatabase_1_1_storable.html">Storable</a> const &amp;storable)</td></tr>
<tr class="memdesc:ac56bf4b6fc7b1481c84e42e6bb6db57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <a class="el" href="classdatabase_1_1_storable.html">Storable</a> object from datbase and cache of storables.  <a href="#ac56bf4b6fc7b1481c84e42e6bb6db57b">More...</a><br /></td></tr>
<tr class="separator:ac56bf4b6fc7b1481c84e42e6bb6db57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc70aa38436efb787b6c9f62941856d"><td class="memTemplParams" colspan="2">template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:abfc70aa38436efb787b6c9f62941856d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedatabase_1_1utils.html#abfc70aa38436efb787b6c9f62941856d">drop_table</a> ()</td></tr>
<tr class="memdesc:abfc70aa38436efb787b6c9f62941856d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the <a class="el" href="classdatabase_1_1_storable.html">Storable</a> table from the database.  <a href="#abfc70aa38436efb787b6c9f62941856d">More...</a><br /></td></tr>
<tr class="separator:abfc70aa38436efb787b6c9f62941856d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e6b2503f6453631d2238ff3f9bc9e3"><td class="memTemplParams" colspan="2">template&lt;typename DataEnum , typename std::enable_if_t&lt; std::is_enum_v&lt; DataEnum &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a84e6b2503f6453631d2238ff3f9bc9e3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedatabase_1_1utils.html#a84e6b2503f6453631d2238ff3f9bc9e3">enum_to_string</a> (DataEnum const &amp;data_enum) -&gt; std::string_view</td></tr>
<tr class="memdesc:a84e6b2503f6453631d2238ff3f9bc9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">to_string function for data enum types  <a href="#a84e6b2503f6453631d2238ff3f9bc9e3">More...</a><br /></td></tr>
<tr class="separator:a84e6b2503f6453631d2238ff3f9bc9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab03452308a27ee3e8e5f30842d8ca8"><td class="memTemplParams" colspan="2">template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:acab03452308a27ee3e8e5f30842d8ca8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedatabase_1_1utils.html#acab03452308a27ee3e8e5f30842d8ca8">get_new_id</a> () -&gt; int</td></tr>
<tr class="memdesc:acab03452308a27ee3e8e5f30842d8ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates new unique ID for the type being asked for.  <a href="#acab03452308a27ee3e8e5f30842d8ca8">More...</a><br /></td></tr>
<tr class="separator:acab03452308a27ee3e8e5f30842d8ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b80f05cca7a094baf577ec5b62108c"><td class="memTemplParams" colspan="2">template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab9b80f05cca7a094baf577ec5b62108c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedatabase_1_1utils.html#ab9b80f05cca7a094baf577ec5b62108c">insert</a> (<a class="el" href="classdatabase_1_1_storable.html">Storable</a> const &amp;storable)</td></tr>
<tr class="memdesc:ab9b80f05cca7a094baf577ec5b62108c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets data from any storable object and inserts it into relevant database.  <a href="#ab9b80f05cca7a094baf577ec5b62108c">More...</a><br /></td></tr>
<tr class="separator:ab9b80f05cca7a094baf577ec5b62108c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d10f5dbf82b7d8008d8d82865c5a19a"><td class="memTemplParams" colspan="2">template&lt;typename Storable , typename... Args, typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8d10f5dbf82b7d8008d8d82865c5a19a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedatabase_1_1utils.html#a8d10f5dbf82b7d8008d8d82865c5a19a">make</a> (Args &amp;&amp;...args) -&gt; <a class="el" href="classdatabase_1_1_storable.html">Storable</a> &amp;</td></tr>
<tr class="memdesc:a8d10f5dbf82b7d8008d8d82865c5a19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a new <a class="el" href="classdatabase_1_1_storable.html">Storable</a> object stores it in the cache, inserts it into the database, and returns a reference to tht new object.  <a href="#a8d10f5dbf82b7d8008d8d82865c5a19a">More...</a><br /></td></tr>
<tr class="separator:a8d10f5dbf82b7d8008d8d82865c5a19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41142b70272ad4b4ec442a28dc5c8ce3"><td class="memTemplParams" colspan="2">template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a41142b70272ad4b4ec442a28dc5c8ce3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedatabase_1_1utils.html#a41142b70272ad4b4ec442a28dc5c8ce3">retrieve_all</a> () -&gt; std::vector&lt; <a class="el" href="classdatabase_1_1_storable.html">Storable</a>, struct Storable::Allocator &gt; &amp;</td></tr>
<tr class="memdesc:a41142b70272ad4b4ec442a28dc5c8ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves all database objects that match the <a class="el" href="classdatabase_1_1_storable.html">Storable</a> that is passed in.  <a href="#a41142b70272ad4b4ec442a28dc5c8ce3">More...</a><br /></td></tr>
<tr class="separator:a41142b70272ad4b4ec442a28dc5c8ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5ce09d7fc593c4395d40fe5c1a0630"><td class="memTemplParams" colspan="2">template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3c5ce09d7fc593c4395d40fe5c1a0630"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedatabase_1_1utils.html#a3c5ce09d7fc593c4395d40fe5c1a0630">table_exists</a> () -&gt; bool</td></tr>
<tr class="memdesc:a3c5ce09d7fc593c4395d40fe5c1a0630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <a class="el" href="classdatabase_1_1_storable.html">Storable</a> table exists in database.  <a href="#a3c5ce09d7fc593c4395d40fe5c1a0630">More...</a><br /></td></tr>
<tr class="separator:a3c5ce09d7fc593c4395d40fe5c1a0630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb264e8826f50ae828a9c89c2906b049"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb264e8826f50ae828a9c89c2906b049"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedatabase_1_1utils.html#acb264e8826f50ae828a9c89c2906b049">type_to_string</a> () -&gt; std::string</td></tr>
<tr class="memdesc:acb264e8826f50ae828a9c89c2906b049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a type to a string and trims the namespaces off. (e.g. namespace::other_namespace::ClassName -&gt; "ClassName")  <a href="#acb264e8826f50ae828a9c89c2906b049">More...</a><br /></td></tr>
<tr class="separator:acb264e8826f50ae828a9c89c2906b049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fc4b4d352c7b947fc48ac8c1d666a6"><td class="memTemplParams" colspan="2">template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad7fc4b4d352c7b947fc48ac8c1d666a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedatabase_1_1utils.html#ad7fc4b4d352c7b947fc48ac8c1d666a6">update</a> (<a class="el" href="classdatabase_1_1_storable.html">Storable</a> const &amp;storable)</td></tr>
<tr class="memdesc:ad7fc4b4d352c7b947fc48ac8c1d666a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the <a class="el" href="classdatabase_1_1_storable.html">Storable</a> objects data within the database.  <a href="#ad7fc4b4d352c7b947fc48ac8c1d666a6">More...</a><br /></td></tr>
<tr class="separator:ad7fc4b4d352c7b947fc48ac8c1d666a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974d01a6dbb387b033f627d846630b92"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:a974d01a6dbb387b033f627d846630b92"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedatabase_1_1utils.html#a974d01a6dbb387b033f627d846630b92">visit_row_data</a> (Lambda const &amp;handler, <a class="el" href="structdatabase_1_1_row.html#a29c16186778c974af723db03751f3aa3">Row::row_data_t</a> const &amp;row_data)</td></tr>
<tr class="memdesc:a974d01a6dbb387b033f627d846630b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the <a class="el" href="classdatabase_1_1_storable.html">Storable</a> objects data within the database.  <a href="#a974d01a6dbb387b033f627d846630b92">More...</a><br /></td></tr>
<tr class="separator:a974d01a6dbb387b033f627d846630b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility functions to insert, retrieve, and manipulate objects in database. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0dd569af49c9913a5090b71c86690fe5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIt , class T , class Compare  = std::less&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto database::utils::binary_find </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds and returns the object if it exists in the stl container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator for the start of the search </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator for the end of the search </td></tr>
    <tr><td class="paramname">comp</td><td>A less than comparison function for the object to be found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the found object, will be the end iterator if now found</dd></dl>
<p>Source: <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a></p>
<p>Requirements: Container must be sorted in relation to the comparison function</p>
<p>Usage: <br />
 auto const compare = [](<a class="el" href="classdatabase_1_1_storable.html">Storable</a> const &amp;lhs, <a class="el" href="classdatabase_1_1_storable.html">Storable</a> const &amp;rhs) { <br />
 return lhs.id() &lt; rhs.id(); <br />
 };</p>
<p><br />
 auto found = <a class="el" href="namespacedatabase_1_1utils.html#a0dd569af49c9913a5090b71c86690fe5" title="Finds and returns the object if it exists in the stl container. ">utils::binary_find</a>(begin(storables), end(storables)); <br />
 if(found != end(storables) { <br />
 // Do something with found object <br />
 } </p>

</div>
</div>
<a class="anchor" id="adae24cb18f62390528243ff3218d8626"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto database::utils::count_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; size_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of <a class="el" href="classdatabase_1_1_storable.html">Storable</a> type in the database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classdatabase_1_1_storable.html">Storable</a></td><td>Any type that is a base of <a class="el" href="classdatabase_1_1_storable.html">Storable</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of rows in the table, 0 if table does not exist</dd></dl>
<p>Creates the following SQLite3 command: <br />
 SELECT count(*) from table_name;</p>
<p>Usage: <br />
 size_t quantity = <a class="el" href="namespacedatabase_1_1utils.html#adae24cb18f62390528243ff3218d8626" title="Count the number of Storable type in the database. ">database::utils::count_rows&lt;food::Food&gt;()</a>; </p>

</div>
</div>
<a class="anchor" id="a303b59245b11befd59f3fd0e838ef80b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void database::utils::create_table </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structdatabase_1_1_column_properties.html">ColumnProperties</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>schema</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create table of <a class="el" href="classdatabase_1_1_storable.html">Storable</a> if not exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classdatabase_1_1_storable.html">Storable</a></td><td>Any type that is a base of <a class="el" href="classdatabase_1_1_storable.html">Storable</a> </td></tr>
    <tr><td class="paramname">schema</td><td>The schema to be used to create the table</td></tr>
  </table>
  </dd>
</dl>
<p>Creates the following SQLite3 command: <br />
 CREATE TABLE IF NOT EXISTS table_name ( <br />
 column_1 data_type PRIMARY KEY, <br />
 column_2 data_type NOT NULL, <br />
 column_3 data_type DEFAULT 0, <br />
 ... <br />
 );</p>
<p>Usage: <br />
 <a class="el" href="namespacedatabase_1_1utils.html#a303b59245b11befd59f3fd0e838ef80b" title="Create table of Storable if not exists. ">database::utils::create_table&lt;food::Food&gt;()</a>; </p>

</div>
</div>
<a class="anchor" id="ac56bf4b6fc7b1481c84e42e6bb6db57b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void database::utils::delete_storable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdatabase_1_1_storable.html">Storable</a> const &amp;&#160;</td>
          <td class="paramname"><em>storable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete <a class="el" href="classdatabase_1_1_storable.html">Storable</a> object from datbase and cache of storables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storable</td><td>Any type that is a base of <a class="el" href="classdatabase_1_1_storable.html">Storable</a></td></tr>
  </table>
  </dd>
</dl>
<p>Creates the following SQLite3 command: <br />
 DELETE <br />
 FROM <br />
 table <br />
 WHERE <br />
 search_condition;</p>
<p>Usage: <br />
 database::utils::delete_storable(food);</p>
<p>Note: delete is a keyword, could not use that. </p>

</div>
</div>
<a class="anchor" id="abfc70aa38436efb787b6c9f62941856d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void database::utils::drop_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the <a class="el" href="classdatabase_1_1_storable.html">Storable</a> table from the database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classdatabase_1_1_storable.html">Storable</a></td><td>Any type that is a base of <a class="el" href="classdatabase_1_1_storable.html">Storable</a></td></tr>
  </table>
  </dd>
</dl>
<p>Creates the following SQLite3 command: DROP TABLE table_name;</p>
<p>Usage: <br />
 <a class="el" href="namespacedatabase_1_1utils.html#abfc70aa38436efb787b6c9f62941856d" title="Deletes the Storable table from the database. ">drop_table&lt;food::Food&gt;()</a>; </p>

</div>
</div>
<a class="anchor" id="a84e6b2503f6453631d2238ff3f9bc9e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataEnum , typename std::enable_if_t&lt; std::is_enum_v&lt; DataEnum &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto database::utils::enum_to_string </td>
          <td>(</td>
          <td class="paramtype">DataEnum const &amp;&#160;</td>
          <td class="paramname"><em>data_enum</em></td><td>)</td>
          <td> -&gt; std::string_view</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>to_string function for data enum types </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_enum</td><td>DataEnum type that is either a constraint type or sql type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string view of the string version of the enum appropriate for a database</dd></dl>
<p>Does not convert to exam string value, it converts to the the string that will be used by the database.</p>
<p>e.g. NULL_ -&gt; "NULL", PRIMARY_KEY -&gt; "PRIMARY KEY" </p>

</div>
</div>
<a class="anchor" id="acab03452308a27ee3e8e5f30842d8ca8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto database::utils::get_new_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates new unique ID for the type being asked for. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classdatabase_1_1_storable.html">Storable</a></td><td>Any type that is a base of <a class="el" href="classdatabase_1_1_storable.html">Storable</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new id that is not being used by the database for this <a class="el" href="classdatabase_1_1_storable.html">Storable</a> type</dd></dl>
<p>Usage: <br />
 int new_id = <a class="el" href="namespacedatabase_1_1utils.html#acab03452308a27ee3e8e5f30842d8ca8" title="Generates new unique ID for the type being asked for. ">database::utils::get_new_id&lt;food::Food&gt;()</a>; </p>

</div>
</div>
<a class="anchor" id="ab9b80f05cca7a094baf577ec5b62108c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void database::utils::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdatabase_1_1_storable.html">Storable</a> const &amp;&#160;</td>
          <td class="paramname"><em>storable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets data from any storable object and inserts it into relevant database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storable</td><td>The object containing data to be stored in a database. Must inherit from <a class="el" href="classdatabase_1_1_storable.html">Storable</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates the following SQLite3 command: <br />
 INSERT INTO table1 ( <br />
 column1, <br />
 column2 ,..) <br />
 VALUES <br />
 ( <br />
 value1, <br />
 value2 ,...);</p>
<p>Usage: <br />
 <a class="el" href="classfood_1_1_food.html" title="The food class stores all macronutrient and micronutrient data for any food. ">food::Food</a> taco("taco", macros); <br />
 database::utils::insert(taco); </p>

</div>
</div>
<a class="anchor" id="a8d10f5dbf82b7d8008d8d82865c5a19a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storable , typename... Args, typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto database::utils::make </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classdatabase_1_1_storable.html">Storable</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a new <a class="el" href="classdatabase_1_1_storable.html">Storable</a> object stores it in the cache, inserts it into the database, and returns a reference to tht new object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>arguments to construct the storable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the new object, copies are not allowed.</dd></dl>
<p>Usage: <br />
 auto &amp;some_food = <a class="el" href="namespacedatabase_1_1utils.html#a8d10f5dbf82b7d8008d8d82865c5a19a" title="Generates a new Storable object stores it in the cache, inserts it into the database, and returns a reference to tht new object. ">database::utils::make&lt;food::Food&gt;</a>("taco", macros); </p>

</div>
</div>
<a class="anchor" id="a41142b70272ad4b4ec442a28dc5c8ce3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto database::utils::retrieve_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::vector&lt;<a class="el" href="classdatabase_1_1_storable.html">Storable</a>, struct Storable::Allocator&gt; &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves all database objects that match the <a class="el" href="classdatabase_1_1_storable.html">Storable</a> that is passed in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classdatabase_1_1_storable.html">Storable</a></td><td>The type of storable object being retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the vector containing all the storable objects of tht type</dd></dl>
<p>Retrieves all objects of the type requested that contain that name.</p>
<p>Creates the following SQLite3 command: <br />
 SELECT * from <a class="el" href="classdatabase_1_1_storable.html">Storable</a>;</p>
<p>Note: Copies of storable objects not allowed</p>
<p>Usage: <br />
 auto all_food = <a class="el" href="namespacedatabase_1_1utils.html#a41142b70272ad4b4ec442a28dc5c8ce3" title="Retrieves all database objects that match the Storable that is passed in. ">database::utils::retrieve_all&lt;food::Food&gt;()</a>; <br />
 for(auto const &amp;food: all_food) { <br />
 // do something <br />
 } </p>

</div>
</div>
<a class="anchor" id="a3c5ce09d7fc593c4395d40fe5c1a0630"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto database::utils::table_exists </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if <a class="el" href="classdatabase_1_1_storable.html">Storable</a> table exists in database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classdatabase_1_1_storable.html">Storable</a></td><td>Any type that is a base of <a class="el" href="classdatabase_1_1_storable.html">Storable</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the table exists, false otherwise</dd></dl>
<p>Creates the following SQLite3 command: <br />
 SELECT name FROM sqlite_master WHERE type='table' AND name='table_name';</p>
<p>Usage: <br />
 if(table_exists&lt;food::Food&gt;()) { <br />
 // do something <br />
 } </p>

</div>
</div>
<a class="anchor" id="acb264e8826f50ae828a9c89c2906b049"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto database::utils::type_to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a type to a string and trims the namespaces off. (e.g. namespace::other_namespace::ClassName -&gt; "ClassName") </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The template parameter T could be any possible type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string of that type passed in as a template parameter</dd></dl>
<p>Usage: <br />
 std::string type_string = <a class="el" href="namespacedatabase_1_1utils.html#acb264e8826f50ae828a9c89c2906b049" title="Converts a type to a string and trims the namespaces off. (e.g. namespace::other_namespace::ClassName...">database::utils::type_to_string&lt;food::Food&gt;()</a>; <br />
 type_string == "Food" // true </p>

</div>
</div>
<a class="anchor" id="ad7fc4b4d352c7b947fc48ac8c1d666a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storable , typename std::enable_if_t&lt; std::is_base_of_v&lt; database::Storable, std::decay_t&lt; Storable &gt;&gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void database::utils::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdatabase_1_1_storable.html">Storable</a> const &amp;&#160;</td>
          <td class="paramname"><em>storable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the <a class="el" href="classdatabase_1_1_storable.html">Storable</a> objects data within the database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storable</td><td>A storable object that already exists within the database and will update the data</td></tr>
  </table>
  </dd>
</dl>
<p>Creates the following SQLite3 command: <br />
 UPDATE <a class="el" href="classdatabase_1_1_storable.html">Storable</a> <br />
 SET column_1 = new_value_1, <br />
 colimn_2 = new_value_2, <br />
 ... <br />
 WHERE Storable_id = Storable_id_value;</p>
<p>Usage: <br />
 auto all_food = <a class="el" href="namespacedatabase_1_1utils.html#a41142b70272ad4b4ec442a28dc5c8ce3" title="Retrieves all database objects that match the Storable that is passed in. ">database::utils::retrieve_all&lt;food::Food&gt;()</a>; <br />
 if(all_food &amp;&amp; all_food.size() &gt; 0) { <br />
 auto my_food = all_food.back(); <br />
 food.set_protein(100); <br />
 database::utils::update(my_food); <br />
 }</p>
<p>Will throw a runtime error if food is not in the database! </p>

</div>
</div>
<a class="anchor" id="a974d01a6dbb387b033f627d846630b92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void database::utils::visit_row_data </td>
          <td>(</td>
          <td class="paramtype">Lambda const &amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdatabase_1_1_row.html#a29c16186778c974af723db03751f3aa3">Row::row_data_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>row_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the <a class="el" href="classdatabase_1_1_storable.html">Storable</a> objects data within the database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A handler that will handle for the row_data_t once it passes the data into it.</td></tr>
    <tr><td class="paramname">row_data</td><td>A std::variant containing multiple data types. See <a class="el" href="structdatabase_1_1_row.html" title="A row of variant data. ">Row</a> implementation or the implementation of this function for all the types it contains.</td></tr>
  </table>
  </dd>
</dl>
<p>Usage: <br />
 std::stringstream column_values; <br />
 <a class="el" href="namespacedatabase_1_1utils.html#a974d01a6dbb387b033f627d846630b92" title="Updates the Storable objects data within the database. ">utils::visit_row_data</a>( <br />
 [&amp;column_values = column_values](auto const &amp;row_data) { <br />
 column_values &lt;&lt; row_data; <br />
 }, <br />
 row_data);</p>
<p>In this example we're using a capture initializer to prevent a dangling reference. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedatabase.html">database</a></li><li class="navelem"><a class="el" href="namespacedatabase_1_1utils.html">utils</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
